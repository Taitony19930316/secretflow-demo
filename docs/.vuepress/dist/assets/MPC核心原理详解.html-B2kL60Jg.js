import{_ as n,c as a,e,o as i}from"./app-CoBy3PVK.js";const l={};function t(r,s){return i(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="mpc-核心原理详解" tabindex="-1"><a class="header-anchor" href="#mpc-核心原理详解"><span>MPC 核心原理详解</span></a></h1><h2 id="一句话概括" tabindex="-1"><a class="header-anchor" href="#一句话概括"><span>一句话概括</span></a></h2><blockquote><p><strong>MPC通过密码学协议将数据和计算过程分散到多方，确保任何单方（即使恶意）都无法破坏数据隐私，同时所有参与方协作完成计算并各自获得结果。</strong></p></blockquote><hr><h2 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想</span></a></h2><h3 id="问题背景" tabindex="-1"><a class="header-anchor" href="#问题背景"><span>问题背景</span></a></h3><p>多个参与方想要共同完成一个计算任务，但每一方都有自己的敏感数据，不愿意暴露给其他人。</p><p><strong>传统方案的困境：</strong></p><ul><li><strong>集中式计算</strong>：数据汇总到中心服务器 → 存在数据泄露风险</li><li><strong>互不信任</strong>：参与方之间无法保证对方不会窥探或篡改数据</li></ul><h3 id="mpc的解决方案" tabindex="-1"><a class="header-anchor" href="#mpc的解决方案"><span>MPC的解决方案</span></a></h3><p>通过三个关键机制实现安全计算：</p><h4 id="_1-秘密分享-secret-sharing" tabindex="-1"><a class="header-anchor" href="#_1-秘密分享-secret-sharing"><span>1. <strong>秘密分享（Secret Sharing）</strong></span></a></h4><p>将每个参与方的数据分割成多个&quot;碎片&quot;，分发给所有参与方。</p><p><strong>核心特性：</strong></p><ul><li>单个碎片不透露任何原始信息</li><li>需要至少 t 个碎片才能还原原始数据</li><li>即使某些参与方是恶意的，也无法破解</li></ul><p><strong>举例：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Alice的秘密数字：x = 42</span>
<span class="line"></span>
<span class="line">分割成3个分片：</span>
<span class="line">- 分片1：s1 = 17  (发给Alice)</span>
<span class="line">- 分片2：s2 = 89  (发给Bob)</span>
<span class="line">- 分片3：s3 = -64 (发给Charlie)</span>
<span class="line"></span>
<span class="line">还原：s1 + s2 + s3 = 17 + 89 - 64 = 42 ✓</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任何单个分片（17、89、-64）都不透露原始数据42的信息。</p><hr><h4 id="_2-安全多方计算协议" tabindex="-1"><a class="header-anchor" href="#_2-安全多方计算协议"><span>2. <strong>安全多方计算协议</strong></span></a></h4><p>在<strong>不还原原始数据</strong>的前提下，直接对分片进行计算。</p><p><strong>核心原理：</strong></p><ul><li>对分片的加法/乘法运算 = 对原始数据的加法/乘法运算</li><li>计算过程中，每一方只看到自己的分片，看不到完整数据</li></ul><p><strong>举例：求和计算</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Alice有：a = 10  →  分片：[a1, a2, a3]</span>
<span class="line">Bob有：  b = 20  →  分片：[b1, b2, b3]</span>
<span class="line"></span>
<span class="line">目标：计算 a + b = ?</span>
<span class="line"></span>
<span class="line">MPC方式：</span>
<span class="line">1. Alice和Bob各自持有自己数据的分片</span>
<span class="line">2. 每一方计算自己的分片和：a1+b1, a2+b2, a3+b3</span>
<span class="line">3. 最后汇总得到结果：30</span>
<span class="line"></span>
<span class="line">全程没有人看到对方的原始数据（10和20）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="_3-防恶意参与者机制" tabindex="-1"><a class="header-anchor" href="#_3-防恶意参与者机制"><span>3. <strong>防恶意参与者机制</strong></span></a></h4><p>即使某些参与方试图作恶，协议依然能保证安全。</p><p><strong>防护措施：</strong></p><ul><li><strong>零知识证明</strong>：证明计算正确，但不泄露数据</li><li><strong>门限机制</strong>：需要超过半数的诚实方才能完成计算</li><li><strong>验证协议</strong>：每一步计算都可以被验证</li></ul><hr><h2 id="核心技术组件" tabindex="-1"><a class="header-anchor" href="#核心技术组件"><span>核心技术组件</span></a></h2><h3 id="_1-shamir秘密分享" tabindex="-1"><a class="header-anchor" href="#_1-shamir秘密分享"><span>1. <strong>Shamir秘密分享</strong></span></a></h3><p><strong>数学原理：</strong> 多项式插值</p><ul><li>一个 t-1 次多项式需要 t 个点才能确定</li><li>将秘密作为多项式的常数项</li><li>分片是多项式上的点</li></ul><p><strong>安全性：</strong> 拿到 t-1 个点 → 无法确定多项式 → 无法获取秘密</p><hr><h3 id="_2-加法同态加密" tabindex="-1"><a class="header-anchor" href="#_2-加法同态加密"><span>2. <strong>加法同态加密</strong></span></a></h3><p><strong>特性：</strong> <code>Enc(a) + Enc(b) = Enc(a + b)</code></p><ul><li>对加密数据直接进行加法运算</li><li>解密后得到的是原始数据的和</li><li>全程不暴露原始数据</li></ul><hr><h3 id="_3-混淆电路-garbled-circuit" tabindex="-1"><a class="header-anchor" href="#_3-混淆电路-garbled-circuit"><span>3. <strong>混淆电路（Garbled Circuit）</strong></span></a></h3><p><strong>应用场景：</strong> 实现任意复杂的逻辑运算</p><ul><li>将计算任务转换为布尔电路</li><li>对电路的每个门进行&quot;混淆&quot;</li><li>逐步计算，但不泄露中间结果</li></ul><hr><h2 id="实际应用场景" tabindex="-1"><a class="header-anchor" href="#实际应用场景"><span>实际应用场景</span></a></h2><h3 id="_1-联合统计分析" tabindex="-1"><a class="header-anchor" href="#_1-联合统计分析"><span>1. <strong>联合统计分析</strong></span></a></h3><p><strong>场景：</strong> 多家医院联合分析患者数据，但不共享原始病历</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">医院A：100名患者数据</span>
<span class="line">医院B：200名患者数据</span>
<span class="line">医院C：150名患者数据</span>
<span class="line"></span>
<span class="line">使用MPC：</span>
<span class="line">- 计算某种疾病的平均发病率</span>
<span class="line">- 统计不同年龄段的患病趋势</span>
<span class="line">- 各医院只知道自己的数据，看不到其他医院的数据</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-多方求最值" tabindex="-1"><a class="header-anchor" href="#_2-多方求最值"><span>2. <strong>多方求最值</strong></span></a></h3><p><strong>场景：</strong> 多家企业比较工资水平，但不愿透露具体薪资</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">企业A：平均薪资 x</span>
<span class="line">企业B：平均薪资 y</span>
<span class="line">企业C：平均薪资 z</span>
<span class="line"></span>
<span class="line">使用MPC：</span>
<span class="line">- 计算三家企业中的最高平均薪资</span>
<span class="line">- 结果：max(x, y, z)</span>
<span class="line">- 没有人知道其他企业的具体数值</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-联合机器学习" tabindex="-1"><a class="header-anchor" href="#_3-联合机器学习"><span>3. <strong>联合机器学习</strong></span></a></h3><p><strong>场景：</strong> 多方数据联合训练AI模型</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">金融机构A：客户交易数据</span>
<span class="line">金融机构B：客户信用数据</span>
<span class="line">金融机构C：客户行为数据</span>
<span class="line"></span>
<span class="line">使用MPC：</span>
<span class="line">- 联合训练风控模型</span>
<span class="line">- 模型效果提升，但数据不出本地</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="与其他技术的对比" tabindex="-1"><a class="header-anchor" href="#与其他技术的对比"><span>与其他技术的对比</span></a></h2><table><thead><tr><th>技术</th><th>数据处理方式</th><th>隐私保护</th><th>计算效率</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>MPC</strong></td><td>分片计算</td><td>强（数学证明）</td><td>中等</td><td>多方联合统计</td></tr><tr><td><strong>PSI</strong></td><td>求交集</td><td>中（仅交集）</td><td>高</td><td>匹配查询</td></tr><tr><td><strong>联邦学习</strong></td><td>梯度聚合</td><td>中（可能泄露）</td><td>高</td><td>分布式训练</td></tr><tr><td><strong>同态加密</strong></td><td>密文计算</td><td>强</td><td>低</td><td>单方外包计算</td></tr></tbody></table><hr><h2 id="技术优势与挑战" tabindex="-1"><a class="header-anchor" href="#技术优势与挑战"><span>技术优势与挑战</span></a></h2><h3 id="✅-优势" tabindex="-1"><a class="header-anchor" href="#✅-优势"><span>✅ 优势</span></a></h3><ol><li><strong>理论安全性强</strong>：有严格的数学证明</li><li><strong>通用性好</strong>：支持任意计算任务</li><li><strong>防恶意参与者</strong>：即使有人作恶也能保证安全</li></ol><h3 id="⚠️-挑战" tabindex="-1"><a class="header-anchor" href="#⚠️-挑战"><span>⚠️ 挑战</span></a></h3><ol><li><strong>计算开销大</strong>：比明文计算慢 100-10000 倍</li><li><strong>通信成本高</strong>：参与方之间需要频繁交互</li><li><strong>参与方数量限制</strong>：参与方越多，性能越差</li></ol><hr><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h2><h3 id="开源框架" tabindex="-1"><a class="header-anchor" href="#开源框架"><span>开源框架</span></a></h3><ol><li><p><strong>SecretFlow MPC模块</strong></p><ul><li>蚂蚁集团开源</li><li>支持多种MPC协议</li><li>与机器学习深度集成</li></ul></li><li><p><strong>MP-SPDZ</strong></p><ul><li>学术界广泛使用</li><li>支持多种安全模型</li><li>性能优化充分</li></ul></li><li><p><strong>ABY框架</strong></p><ul><li>混合协议设计</li><li>算术/布尔/姚氏混淆电路</li></ul></li></ol><hr><h2 id="核心数学基础" tabindex="-1"><a class="header-anchor" href="#核心数学基础"><span>核心数学基础</span></a></h2><h3 id="_1-模运算" tabindex="-1"><a class="header-anchor" href="#_1-模运算"><span>1. 模运算</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">(a + b) mod p = ((a mod p) + (b mod p)) mod p</span>
<span class="line">(a × b) mod p = ((a mod p) × (b mod p)) mod p</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>作用：</strong> 确保分片在有限域内，防止数值溢出</p><hr><h3 id="_2-拉格朗日插值" tabindex="-1"><a class="header-anchor" href="#_2-拉格朗日插值"><span>2. 拉格朗日插值</span></a></h3><p><strong>公式：</strong></p><p>[ f(x) = \\sum_{i=0}^{t-1} y_i \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j} ]</p><p><strong>作用：</strong> 从 t 个点还原多项式，进而获取秘密</p><hr><h3 id="_3-同态性质" tabindex="-1"><a class="header-anchor" href="#_3-同态性质"><span>3. 同态性质</span></a></h3><p><strong>加法同态：</strong> <code>f(a + b) = f(a) + f(b)</code></p><p><strong>乘法同态：</strong> <code>f(a × b) = f(a) × f(b)</code></p><p><strong>作用：</strong> 在加密状态下进行计算</p><hr><h2 id="安全性证明思路" tabindex="-1"><a class="header-anchor" href="#安全性证明思路"><span>安全性证明思路</span></a></h2><h3 id="半诚实模型-semi-honest" tabindex="-1"><a class="header-anchor" href="#半诚实模型-semi-honest"><span>半诚实模型（Semi-Honest）</span></a></h3><p><strong>假设：</strong> 参与方会按照协议执行，但会尝试从中间结果推断信息</p><p><strong>证明方法：</strong> 模拟范式（Simulation Paradigm）</p><ul><li>证明任何参与方看到的信息都可以用&quot;模拟器&quot;生成</li><li>因此，真实协议不泄露任何额外信息</li></ul><hr><h3 id="恶意模型-malicious" tabindex="-1"><a class="header-anchor" href="#恶意模型-malicious"><span>恶意模型（Malicious）</span></a></h3><p><strong>假设：</strong> 参与方可能任意偏离协议</p><p><strong>防护措施：</strong></p><ul><li>零知识证明：证明每一步计算正确</li><li>承诺方案：先承诺数据，再揭示</li><li>可验证秘密分享（VSS）</li></ul><hr><h2 id="实际性能数据" tabindex="-1"><a class="header-anchor" href="#实际性能数据"><span>实际性能数据</span></a></h2><h3 id="计算开销对比" tabindex="-1"><a class="header-anchor" href="#计算开销对比"><span>计算开销对比</span></a></h3><table><thead><tr><th>任务</th><th>明文计算</th><th>MPC计算</th><th>倍数</th></tr></thead><tbody><tr><td>100万次加法</td><td>10 ms</td><td>1.5 秒</td><td>150x</td></tr><tr><td>10万次乘法</td><td>5 ms</td><td>2.3 秒</td><td>460x</td></tr><tr><td>AES加密(128bit)</td><td>0.1 ms</td><td>50 ms</td><td>500x</td></tr></tbody></table><h3 id="通信开销" tabindex="-1"><a class="header-anchor" href="#通信开销"><span>通信开销</span></a></h3><ul><li><strong>2方协议</strong>：每次运算 ~1KB 通信</li><li><strong>3方协议</strong>：每次运算 ~3KB 通信</li><li><strong>n方协议</strong>：每次运算 ~O(n²) 通信</li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>MPC的本质是：</p><blockquote><p><strong>通过数学和密码学的巧妙设计，让多方能够在&quot;看不见彼此数据&quot;的情况下，共同完成计算任务。</strong></p></blockquote><p><strong>三大支柱：</strong></p><ol><li><strong>秘密分享</strong> - 数据分割规则</li><li><strong>安全协议</strong> - 计算执行规则</li><li><strong>防恶意机制</strong> - 作恶检测规则</li></ol><p><strong>核心价值：</strong></p><ul><li>打破数据孤岛</li><li>保护数据主权</li><li>实现数据&quot;可用不可见&quot;</li></ul>`,110)])])}const p=n(l,[["render",t]]),o=JSON.parse('{"path":"/devlog/tech-principles/MPC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html","title":"MPC 核心原理详解","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761812064000,"contributors":[{"name":"tailunyu","username":"tailunyu","email":"tailunyu@example.com","commits":1,"url":"https://github.com/tailunyu"}],"changelog":[{"hash":"21ff0670eba65ed2304fa6d62de097417a227767","time":1761812064000,"email":"tailunyu@example.com","author":"tailunyu","message":"重构开发手记：改为知识点集合，新增MPC原理详解"}]},"filePathRelative":"devlog/tech-principles/MPC核心原理详解.md"}');export{p as comp,o as data};
