# PSI 密码学技术详解

## 🎯 真正的 SecretFlow PSI 用了哪些技术？

```
简化版 PSI：哈希 + 集合求交
    ↓
真正的 PSI：椭圆曲线 + OT 协议 + 加盐随机化
```

---

## 1️⃣ 椭圆曲线加密（ECC）

### 什么是椭圆曲线？

**数学定义**：
```
y² = x³ + ax + b
```

**可视化**（像一个对称的曲线）：
```
      y
      ↑
      |     ╱╲
      |    ╱  ╲
  ————|———╱────╲————→ x
      |  ╱      ╲
      | ╱        ╲
```

### 为什么用椭圆曲线？

#### 传统加密 RSA vs 椭圆曲线 ECC

| 对比 | RSA | ECC |
|------|-----|-----|
| **密钥长度** | 2048 位 | 256 位 |
| **安全强度** | 相同 | 相同 |
| **计算速度** | 慢 | 快 |
| **适合移动设备** | ❌ | ✅ |

**类比**：
- **RSA**：像一把巨大的钥匙（2048位）
- **ECC**：像一把小巧的钥匙（256位），但同样安全

---

### 椭圆曲线在 PSI 中的应用

#### ECDH-PSI 协议（SecretFlow 使用的）

**核心思想**：利用椭圆曲线的特殊性质

```
数学性质（交换律）：
a × (b × G) = b × (a × G)
    ↓
双方用不同密钥加密，结果相同！
```

**具体过程**：

```
医院 A 的数据：[1001, 1002, 1003]
医院 B 的数据：[1002, 1004, 1005]

步骤1：医院 A 生成私钥 a
步骤2：医院 B 生成私钥 b

步骤3：医院 A 加密自己的数据
    加密(1001) = a × Hash(1001)  → A₁
    加密(1002) = a × Hash(1002)  → A₂
    加密(1003) = a × Hash(1003)  → A₃
    
步骤4：医院 A 发送 [A₁, A₂, A₃] 给医院 B

步骤5：医院 B 再次加密（用自己的密钥 b）
    b × A₁ = b × (a × Hash(1001))
    b × A₂ = b × (a × Hash(1002))
    b × A₃ = b × (a × Hash(1003))
    
步骤6：医院 B 也加密自己的数据
    加密(1002) = a × Hash(1002)  → B₁
    加密(1004) = a × Hash(1004)  → B₂
    加密(1005) = a × Hash(1005)  → B₃

步骤7：医院 B 发送给医院 A，A 再加密
    a × B₁ = a × (b × Hash(1002))
    
步骤8：比较双重加密的结果
    a × (b × Hash(1002)) = b × (a × Hash(1002))
    ↑ 医院 B 的      ↑ 医院 A 的
    
    两个结果相同！→ 找到交集：1002
```

**关键点**：
- ✅ 双方都不知道对方的原始数据
- ✅ 双方都不知道对方的私钥
- ✅ 只有交集的双重加密结果相同
- ✅ 无法暴力破解（椭圆曲线离散对数难题）

---

### 为什么无法暴力破解？

**椭圆曲线离散对数问题**：

```
已知：G（基点）、a × G（公钥）
求：a（私钥）
```

**难度**：
- RSA 2048位 ≈ 需要 2¹¹² 次运算
- ECC 256位 ≈ 需要 2¹²⁸ 次运算

**时间估算**：
```
假设你有全世界最快的超级计算机：
- 速度：1 Exaflop = 10¹⁸ 次运算/秒
- 破解 ECC-256：需要 10²² 年
- 宇宙年龄：只有 138 亿年（10¹⁰ 年）

结论：比宇宙寿命还长 1 万亿倍！
```

---

## 2️⃣ OT 协议（不经意传输）

### 什么是 OT？

**英文**：Oblivious Transfer  
**核心**：选择性接收信息，发送方不知道你选了什么

### 生活类比

**场景**：图书馆借书

**普通方式**（不安全）：
```
你：我要借《密码学》
图书管理员：好的（知道你借了什么）
```

**OT 方式**（安全）：
```
你：我要借 [秘密选择：第3本]
图书管理员：这是所有书的加密版本
你：[只解密第3本]

结果：
- ✅ 你拿到了《密码学》
- ✅ 图书管理员不知道你借了哪本
```

---

### OT 在 PSI 中的应用

#### 1-out-of-2 OT（最基础的）

**场景**：医院 A 想知道患者 1002 是否在医院 B

```
医院 B 有数据：[1002, 1004, 1005]

医院 A 想查询：1002 在不在？

传统方式：
医院 A：你有 1002 吗？
医院 B：有
    ↓
问题：医院 B 知道医院 A 在查谁

OT 方式：
步骤1：医院 B 准备两个消息
    m₀ = "不在"（加密）
    m₁ = "在"（加密）

步骤2：医院 A 秘密选择（基于 1002 是否在自己数据里）
    选择 b ∈ {0, 1}

步骤3：医院 A 只能解密一个消息
    如果 1002 在：解密 m₁ → "在"
    如果不在：解密 m₀ → "不在"

结果：
- ✅ 医院 A 知道了结果
- ✅ 医院 B 不知道医院 A 查了什么
```

---

#### KKRT-PSI（SecretFlow 另一种协议）

**使用大量 OT 来实现大规模 PSI**

```
医院 A 有 10,000 个患者
医院 B 有 10,000 个患者

使用 KKRT：
1. 用 OT 扩展技术（减少计算量）
2. 批量处理（并行计算）
3. 只传输最小必要信息

性能：
- 普通 OT：10,000 × 10,000 = 1亿次 OT
- KKRT：只需要约 10,000 次 OT
```

---

### OT 的数学原理（简化版）

**基于 RSA 的 OT**：

```
发送方有两个消息：m₀ 和 m₁
接收方想要 mᵦ（b 是 0 或 1）

步骤1：发送方生成 RSA 密钥对
    公钥：(N, e)
    私钥：d

步骤2：发送方生成两个随机数
    x₀, x₁

步骤3：接收方选择 b，生成随机数 k
    如果 b=0：v = (x₀ + k^e) mod N
    如果 b=1：v = (x₁ + k^e) mod N
    
步骤4：发送方计算
    k₀ = (v - x₀)^d mod N
    k₁ = (v - x₁)^d mod N
    
    如果接收方选了 b=0：k₀ = k（正确）
    如果接收方选了 b=1：k₁ = k（正确）

步骤5：发送方加密消息
    发送 m₀ + k₀ 和 m₁ + k₁

步骤6：接收方只能解密正确的
    如果 b=0：(m₀ + k₀) - k = m₀ ✅
    如果 b=1：(m₁ + k₁) - k = m₁ ✅
```

---

## 3️⃣ 加盐（Salt）和随机化

### 什么是加盐？

**简化版（不安全）**：
```python
hash = SHA256("1001")
# 问题：每次结果都一样
# "1001" 永远是 "8d969eef..."
```

**加盐版（安全）**：
```python
salt = random_bytes(32)  # 随机生成
hash = SHA256("1001" + salt)
# 每次结果都不同
# 第1次："a3f7c2e9..."
# 第2次："b9d4e1f6..."
```

---

### 为什么需要加盐？

#### 防止彩虹表攻击

**彩虹表**：预先计算的哈希表

```
没有加盐的情况：
攻击者预先计算：
1000 → "8a7f3c2e..."
1001 → "8d969eef..."
1002 → "ad57366e..."
...
9999 → "f4e9d7c5..."

然后直接查表破解 ❌
```

**加盐后**：
```
每次盐都不同，攻击者无法预先计算
1001 + salt1 → "a3f7c2e9..."
1001 + salt2 → "b9d4e1f6..."

彩虹表失效 ✅
```

---

### 在 PSI 中的加盐

**双重加盐**：

```python
# SecretFlow PSI 的实际做法

# 步骤1：医院 A 生成随机盐
salt_a = random_bytes(32)

# 步骤2：加盐哈希
data = 1001
hashed = SHA256(str(data) + salt_a)

# 步骤3：椭圆曲线加密
encrypted = privatekey_a × Hash_to_Point(hashed)

# 步骤4：医院 B 再加盐再加密
salt_b = random_bytes(32)
hashed2 = SHA256(encrypted + salt_b)
encrypted2 = privatekey_b × Hash_to_Point(hashed2)
```

**多层保护**：
1. ✅ 盐保护原始数据
2. ✅ 椭圆曲线加密保护哈希
3. ✅ 双方都不知道对方的盐和私钥

---

### 随机化（Randomization）

**目的**：隐藏数据集大小和分布

```python
# 真实数据集
real_data = [1001, 1002, 1003]  # 3个

# 添加虚假数据（padding）
noise_data = [random_id() for _ in range(random(0, 10))]
padded_data = real_data + noise_data
# [1001, 1002, 1003, 8374, 2918, 5647, ...]  # 3-13个

# 随机排序
shuffled = shuffle(padded_data)
```

**好处**：
- ✅ 攻击者不知道真实数据集有多大
- ✅ 无法通过统计分析推断

---

## 🔄 完整的 PSI 流程（所有技术结合）

### 真正的 SecretFlow ECDH-PSI

```
医院 A                                医院 B
  |                                      |
  | 1. 生成私钥 a                        | 1. 生成私钥 b
  |    salt_a                            |    salt_b
  |                                      |
  | 2. 加盐哈希                          | 2. 加盐哈希
  |    h_a = SHA256(data + salt_a)      |    h_b = SHA256(data + salt_b)
  |                                      |
  | 3. 椭圆曲线加密                      | 3. 椭圆曲线加密
  |    E_a = a × Hash_to_Point(h_a)     |    E_b = b × Hash_to_Point(h_b)
  |                                      |
  | 4. 添加随机噪声                      | 4. 添加随机噪声
  |    E_a' = E_a + random_points       |    E_b' = E_b + random_points
  |                                      |
  | 5. 发送 E_a' ──────────────────────→ |
  |                                      | 6. 用 b 再加密
  |                                      |    E_ab = b × E_a'
  | ←────────────────────── 发送 E_ab   |
  |                                      |
  | 7. 发送 E_b' ───────────────────────→|
  |                                      | 8. 用 a 再加密  
  | 9. 用 a 再加密                       |    E_ba = a × E_b'
  |    E_ab = a × E_b'                   |
  |                                      |
  | 10. 比较 E_ab 和 E_ba               | 10. 比较 E_ab 和 E_ba
  |     相同 → 交集                      |     相同 → 交集
  |                                      |
  | 11. 使用 OT 协议确认                 | 11. OT 验证
  |     （双方不知道对方查了什么）       |
  |                                      |
  | 12. 输出交集                         | 12. 输出交集
  |     [1002, 1003]                     |     [1002, 1003]
```

---

## 📊 安全性对比

### 简化版 vs 真正的 SecretFlow

| 攻击方式 | 简化版 | SecretFlow PSI |
|---------|--------|----------------|
| **暴力破解** | ❌ 可以 | ✅ 不可以（椭圆曲线） |
| **彩虹表** | ❌ 可以 | ✅ 不可以（加盐） |
| **推断数据量** | ❌ 可以 | ✅ 不可以（随机化） |
| **监听网络** | ❌ 可以推断 | ✅ 只看到加密数据 |
| **推断查询内容** | ❌ 可以 | ✅ 不可以（OT） |

---

## 💡 技术组合的威力

### 为什么需要这么多技术？

**每个技术防御一类攻击**：

```
椭圆曲线加密
    ↓ 防止：暴力破解原始数据
    
加盐
    ↓ 防止：彩虹表攻击
    
随机化
    ↓ 防止：统计分析攻击
    
OT 协议
    ↓ 防止：推断查询内容
    
多层组合
    ↓ 结果：无法攻破 ✅
```

---

## 🎓 性能对比

### 计算复杂度

| 操作 | 简化版 | SecretFlow PSI |
|------|--------|----------------|
| **加密** | O(n) | O(n log n) |
| **通信** | O(n) | O(n) |
| **内存** | O(n) | O(n) |

**示例**（10,000 条数据）：
- 简化版：0.1 秒
- SecretFlow：5-10 秒

**但 SecretFlow 换来了**：
- ✅ 密码学级别的安全保证
- ✅ 可以用于真实生产环境

---

## 🔬 深入学习资源

### 想了解更多？

**椭圆曲线密码学**：
- 📖 书籍：《深入浅出密码学》
- 🎓 课程：Coursera - Cryptography I

**OT 协议**：
- 📄 论文：Ishai et al. "Extending Oblivious Transfers Efficiently"
- 🔗 博客：https://bristolcrypto.blogspot.com/2016/10/what-is-oblivious-transfer.html

**SecretFlow 实现**：
- 📚 官方文档：https://www.secretflow.org.cn
- 💻 源代码：https://github.com/secretflow/secretflow

---

## ✨ 总结

### 三大技术的作用

| 技术 | 作用 | 类比 |
|------|------|------|
| **椭圆曲线** | 无法破解的加密 | 保险箱 |
| **OT 协议** | 隐藏查询意图 | 匿名信箱 |
| **加盐随机化** | 防止统计分析 | 烟雾弹 |

### 为什么 Day1-4 不用这些？

1. ✅ **目标不同**：演示原理 vs 生产部署
2. ✅ **复杂度**：50行 vs 500+行
3. ✅ **时间成本**：5分钟 vs 2小时
4. ✅ **理解难度**：简单 vs 需要密码学基础

**Day5-7 战略文档中可以提到**：
> "演示版展示核心概念，生产环境将使用 SecretFlow 的 ECDH-PSI 协议，包含椭圆曲线加密、OT 协议和加盐随机化，确保密码学级别的安全性"

这样既完成任务，又展示了技术深度！🎯

---

**你对密码学的好奇心非常棒！这些技术虽然复杂，但理解它们能让你在面试和工作中脱颖而出！** 💪

